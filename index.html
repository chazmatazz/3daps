<!-- Copyright Kate Starbird 2009 -->
<!--
Kate Starbird's 3DAPS system - Own Your Avatar!

This builds off Google's sample o3d code - towards an Avatar controller.
-->
<html>
<head>
<title>
Kate Starbird's 3DAPS system - Own Your Avatar!
</title>
<style type="text/css">
  html, body {
    height: 100%;
    margin: 0;
    padding: 0;
    border: none;
    font-family: Arial, sans-serif;
  }

#o3d {
float: right;
height: 100%;
width: 50%;
}

#code {
height: 90%;
}

#textbox {
height: 100%;
width: 49%;
font-family: "courier new", courier, monospace;
font-size:105%;
}

#dialog-message {
	display: none;
	font-size: 70%;
}
</style>
<link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/jqueryui/1/themes/cupertino/jquery-ui.css" type="text/css" />
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1/jquery-ui.min.js"></script>
<script src="o3d-webgl/base.js"></script>
<script src="o3djs/base.js"></script>
<script>

var local_urls = {
	kate: "examples/kate.js",
	yoga: "examples/yoga.js"
};

var default_code = local_urls.kate;

var first_run = true;
function populate_dropdown(target, data) {
	for(var val in data) {
	    $('<option />', {value: data[val], text: val, selected: (data[val] == default_code)}).appendTo(target);
	}
}
function load_code(url) {
	$.get(url, function(data) {
   		$("textarea#textbox").val(data);
   		  if(first_run && qs["autorun"]) {
		  	run_user_script();
		  	first_run = false;
		  }
   }, "html");
}

var base_url = window.location.href.substring(0, window.location.href.length - window.location.search.length);

function autorun(example) {
	$("#share-url").html(base_url + "?autorun=1&example=" + example);
	$( "#dialog-message" ).dialog({
			modal: true,
			buttons: {
				Ok: function() {
					$( this ).dialog( "close" );
				}
			}
		});
	
}

var qs = (function(a) {
    if (a == "") return {};
    var b = {};
    for (var i = 0; i < a.length; ++i)
    {
        var p=a[i].split('=');
        if (p.length != 2) continue;
        b[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
    }
    return b;
})(window.location.search.substr(1).split('&'));

function load_example() {
	load_code($("#example_list").val());
}

function share_example() {
	autorun($("#example_list option:selected").text());
}


o3djs.base.o3d = o3d;
o3djs.require('o3djs.webgl');

o3djs.require('o3djs.util');
o3djs.require('o3djs.math');
o3djs.require('o3djs.rendergraph');
o3djs.require('o3djs.primitives');
o3djs.require('o3djs.material');

// Events
// init() once the page has finished loading.
// unload() when the page is unloaded.
window.onload = init;
//window.onunload= unload;

// constants
var MOVE_VELOCITY = 25;  // in units per second.
var ROTATE_VELOCITY = 1; // in radians per second

// global variables
var g_o3dElement;
var g_o3d;
var g_math;
var g_client;
var g_viewInfo;
var g_pack;
var g_globalParams;
var g_o3dWidth;
var g_o3dHeight;
var g_o3dElement;
var g_keyDown = [];  // which keys are down by key code.

var g_playerTransform = [];
var g_playerJoint = [];
var g_playerMovement = [];

var g_eye = [15, 15, 60];
var g_target = [0, 0, 0];
var g_up = [0, 1, 0];
var g_viewMatrix;

var g_error = 0;
var g_functions;
var g_values;
var g_names;
var return_register = "";


/**
 * Updates the projection matrix.
 */
function updateProjection() {
  g_viewInfo.drawContext.projection = g_math.matrix4.perspective(
    g_math.degToRad(45),       // field of view.
    g_o3dWidth / g_o3dHeight,  // aspect ratio
    0.1,                       // Near plane.
    5000);                     // Far plane.
}

/*
 * Updates the camera.
 */
function updateCamera() {
  g_viewMatrix = g_math.matrix4.lookAt(g_eye, g_target, g_up);
  g_viewInfo.drawContext.view = g_viewMatrix;
};

/**
 * Updates global variables of the client's size if they have changed.
 */
function updateClientSize() {
  var newWidth = g_client.width;
  var newHeight = g_client.height;
  if (g_o3dWidth != newWidth || g_o3dHeight != newHeight) {
    g_o3dWidth = newWidth;
    g_o3dHeight = newHeight;
    updateProjection();
  }
}

/**
 * Creates the client area.
 */
function init() {
	populate_dropdown($("#example_list"), local_urls);
	if(local_urls.hasOwnProperty(qs["example"])) {
		load_code(local_urls[qs["example"]]);
	} else {
		load_code(default_code);
	}
	
  o3djs.webgl.makeClients(initStep2);
}

/**
 * Initializes O3D and creates the BASIC character shape.
 * @param {Array} clientElements Array of o3d object elements.
 */
function initStep2(clientElements) {
  // Initializes global variables and libraries.
  g_o3dElement = clientElements[0];
  g_o3d = g_o3dElement.o3d;
  g_math = o3djs.math;
  g_client = g_o3dElement.client;
  
  // Creates a pack to manage our resources/assets
  g_pack = g_client.createPack();

  g_root = g_pack.createObject('Transform');

  g_viewInfo = o3djs.rendergraph.createBasicView(
      g_pack,
      g_root,
      g_client.renderGraphRoot);
  
  g_viewInfo.clearBuffer.clearColor = [
      0.88,0.85,0.8,1];

  updateCamera();

  var redMaterial = o3djs.material.createBasicMaterial(
      g_pack,
      g_viewInfo,
      [0.2, 0.4, 0.5, 1]);  // green

 // var checkerMaterial = o3djs.material.createMaterialFromFile(
   //   g_pack, 'shaders/checker.shader', g_viewInfo.performanceDrawList);

  g_globalParams = o3djs.material.createAndBindStandardParams(g_pack);
  g_globalParams.lightWorldPos.value = [30, 60, 40];
  g_globalParams.lightColor.value = [1, 1, 1, 1];

  // Create the body for my character
  var bodyShape = o3djs.primitives.createBox(
      g_pack, redMaterial, 6.5, 8, 3,
      g_math.matrix4.translation([0, 4, 0]));

  var transformCOG = g_pack.createObject('Transform');
  transformCOG.parent = g_root;

  var bendCOG = g_pack.createObject('Transform');
  bendCOG.parent = transformCOG;
  bendCOG.addShape(bodyShape);

  // Create a head for my character
  var head = o3djs.primitives.createSphere(
	g_pack, redMaterial, 2.5, 18, 18,
	g_math.matrix4.translation([0, 11, 0]));
  var transformHead = g_pack.createObject('Transform');
  transformHead.parent = bendCOG;
  transformHead.addShape(head);

  // Create arms for my character - left
  var upper_arm_left = o3djs.primitives.createCylinder(
      g_pack, redMaterial, 1, 5.25, 18, 10,
      g_math.matrix4.translation([4, 4.625, 0]));
  var joint_arm_left = o3djs.primitives.createSphere(
	g_pack, redMaterial, 1.05, 18, 18,
	g_math.matrix4.translation([4, 2.0, 0]));
  var transformArmLeft = g_pack.createObject('Transform');
  transformArmLeft.parent = bendCOG;
  transformArmLeft.addShape(upper_arm_left);
  transformArmLeft.addShape(joint_arm_left);
  
  var lower_arm_left = o3djs.primitives.createCylinder(
      g_pack, redMaterial, 1, 4.25, 18, 10,
      g_math.matrix4.translation([4, -0.125, 0]));
  var transformLowerArmLeft = g_pack.createObject('Transform');
  transformLowerArmLeft.parent = transformArmLeft;
  transformLowerArmLeft.addShape(lower_arm_left);

 // Create arms for my character - right
  var upper_arm_right = o3djs.primitives.createCylinder(
      g_pack, redMaterial, 1, 5.25, 18, 10,
      g_math.matrix4.translation([-4, 4.625, 0]));
  var joint_arm_right = o3djs.primitives.createSphere(
	g_pack, redMaterial, 1.05, 18, 18,
	g_math.matrix4.translation([-4, 2.0, 0]));
  var transformArmRight = g_pack.createObject('Transform');
  transformArmRight.parent = bendCOG;
  transformArmRight.addShape(upper_arm_right);
  transformArmRight.addShape(joint_arm_right);
  
  var lower_arm_right = o3djs.primitives.createCylinder(
      g_pack, redMaterial, 1, 4.25, 18, 10,
      g_math.matrix4.translation([-4, -0.125, 0]));
  var transformLowerArmRight = g_pack.createObject('Transform');
  transformLowerArmRight.parent = transformArmRight;
  transformLowerArmRight.addShape(lower_arm_right);

  // Create legs for my character -left
  var upper_leg_left = o3djs.primitives.createCylinder(
      g_pack, redMaterial, 1.5, 6.75, 18, 10,
      g_math.matrix4.translation([1.8, -3.375, 0]));
  var knee_left = o3djs.primitives.createSphere(
	g_pack, redMaterial, 1.55, 18, 18,
	g_math.matrix4.translation([1.8, -6.75, 0]));
  var transformLegLeft = g_pack.createObject('Transform');
  transformLegLeft.parent = transformCOG;
  transformLegLeft.addShape(upper_leg_left);
  transformLegLeft.addShape(knee_left);

  var lower_leg_left = o3djs.primitives.createCylinder(
      g_pack, redMaterial, 1.5, 6, 18, 10,
      g_math.matrix4.translation([1.8, -9.75, 0]));
  var transformLowerLegLeft = g_pack.createObject('Transform');
  transformLowerLegLeft.parent = transformLegLeft;
  transformLowerLegLeft.addShape(lower_leg_left);
  
  var foot_left = o3djs.primitives.createBox(
      g_pack, redMaterial, 2.4, 1.2, 4.3,
      g_math.matrix4.translation([1.8, -13, 0.8]));
  var transformFootLeft = g_pack.createObject('Transform');
  transformFootLeft.parent = transformLowerLegLeft;
  transformFootLeft.addShape(foot_left);

  // Create legs for my character - right
  var upper_leg_right = o3djs.primitives.createCylinder(
      g_pack, redMaterial, 1.5, 6.75, 18, 10,
      g_math.matrix4.translation([-1.8, -3.375, 0]));
  var knee_right = o3djs.primitives.createSphere(
	g_pack, redMaterial, 1.55, 18, 18,
	g_math.matrix4.translation([-1.8, -6.75, 0]));
  var transformLegRight = g_pack.createObject('Transform');
  transformLegRight.parent = transformCOG;
  transformLegRight.addShape(upper_leg_right);
  transformLegRight.addShape(knee_right);

  var lower_leg_right = o3djs.primitives.createCylinder(
      g_pack, redMaterial, 1.5, 6, 18, 10,
      g_math.matrix4.translation([-1.8, -9.75, 0]));
  var transformLowerLegRight = g_pack.createObject('Transform');
  transformLowerLegRight.parent = transformLegRight;
  transformLowerLegRight.addShape(lower_leg_right);
  
  var foot_right = o3djs.primitives.createBox(
      g_pack, redMaterial, 2.4, 1.2, 4.3,
      g_math.matrix4.translation([-1.8, -13, 0.8]));
  var transformFootRight = g_pack.createObject('Transform');
  transformFootRight.parent = transformLowerLegRight;
  transformFootRight.addShape(foot_right);

  g_playerTransform[0] = transformCOG;
  g_playerTransform[1] = bendCOG;
  g_playerTransform[2] = transformArmLeft;
  g_playerTransform[3] = transformArmRight;
  g_playerTransform[4] = transformLegLeft;
  g_playerTransform[5] = transformLegRight;
  g_playerTransform[6] = transformHead;
  g_playerTransform[7] = transformLowerArmLeft;
  g_playerTransform[8] = transformLowerArmRight;
  g_playerTransform[9] = transformLowerLegLeft;
  g_playerTransform[10] = transformLowerLegRight;
  g_playerTransform[11] = transformFootLeft;
  g_playerTransform[12] = transformFootRight;

  g_playerJoint[0] = new Joint(0, 0, 0, 0);
  g_playerJoint[1] = new Joint(1, 0, 0, 0);
  g_playerJoint[2] = new Joint(2, 4, 7.5, 0);
  g_playerJoint[3] = new Joint(3, -4, 7.5, 0);
  g_playerJoint[4] = new Joint(4, 1.8, 0, 0);
  g_playerJoint[5] = new Joint(5, -1.8, 0, 0);
  g_playerJoint[6] = new Joint(6, 0, 8, 0);
  g_playerJoint[7] = new Joint(7, 4, 2, 0);
  g_playerJoint[8] = new Joint(8, -4, 2, 0);
  g_playerJoint[9] = new Joint(9, 1.8, -6.75, 0);
  g_playerJoint[10] = new Joint(10, -1.8, -6.75, 0);
  g_playerJoint[11] = new Joint(11, 1.8, -13, 0);
  g_playerJoint[12] = new Joint(12, -1.8, -13, 0);
  
  // Setup a render callback for per frame processing.
  g_client.setRenderCallback(onRender);

  o3djs.event.addEventListener(g_o3dElement, 'keydown', onKeyDown);
  o3djs.event.addEventListener(g_o3dElement, 'keyup', onKeyUp);
}

// constructor for Joint Class
function Joint(t_index, distx, disty, distz)
{
	this.transform_index = t_index;
	this.x = distx;			// distance from origin x	
	this.y = disty;
	this.z = distz;
}

// constructor for Movement Class
function SingleMovement(x, y, z, xrot, yrot, zrot, time, index)
{
	this.cId = "SingleMovement";
	this.x_loc = x;
	this.y_loc = y;
	this.z_loc = z;
	this.x_rot = xrot;
	this.y_rot = yrot;
	this.z_rot = zrot;
	this.time = time;
	this.index = index;			// index of the joint for the movement

}

// constructor for Movement Class
function SingleMovementTo(x, y, z, time, index)
{
	this.cId = "SingleMovementTo";
	this.x_loc = x;
	this.y_loc = y;
	this.z_loc = z;
	this.time = time;
	this.index = index;			// index of the joint for the movement

}

// constructor for identity movement class
function Identity(index)
{
	this.cId = "Identity";
	this.index = index;			// index of the joint for the movement

}

function OrderMovements(arr)
{
	this.cId = "OrderMovements";
	this.movements = [];
	for (var i=0; i<arr.length; i++) {
		this.movements.push(arr[i]);
	}
}

function TogetherMovements(arr)
{
	this.cId = "TogetherMovements";
	this.movements = [];
	for (var i=0; i<arr.length; i++) {
		this.movements.push(arr[i]);
	}
}

function UserFunction(name, cmds, args)
{
	this.name = name;
	this.commands = cmds;
	this.arg_names = args;
}


// loop through all the animations and execute
function animate(time_inc) {
	for (var i=0; i < g_playerMovement.length; i++) {
		move = g_playerMovement[i];
		execute_move(move, time_inc);		
	} 
}

// recursive function to execute single moves, moves in order, or moves done together
function execute_move(move, etime)
{
	switch (move.cId) {

		case "SingleMovement":

			if (move.time > 0) {
				if (etime > move.time) {
					etime = move.time;
				}

				var movex = etime * move.x_loc / move.time;
				var movey = etime * move.y_loc / move.time;
				var movez = etime * move.z_loc / move.time;
				var rotx = etime * move.x_rot / move.time;
				var roty = etime * move.y_rot / move.time;
				var rotz = etime * move.z_rot / move.time;
	
				g_playerTransform[move.index].translate(g_playerJoint[move.index].x, g_playerJoint[move.index].y, g_playerJoint[move.index].z);
				g_playerTransform[move.index].translate(movex, movey, movez);
				g_playerTransform[move.index].rotateX(rotx);
				g_playerTransform[move.index].rotateY(roty);			
				g_playerTransform[move.index].rotateZ(rotz);
				g_playerTransform[move.index].translate(-g_playerJoint[move.index].x, -g_playerJoint[move.index].y, -g_playerJoint[move.index].z);

				move.x_loc -= movex;
				move.y_loc -= movey;
				move.z_loc -= movez;
				move.x_rot -= rotx;
				move.y_rot -= roty;
				move.z_rot -= rotz;
				move.time -= etime;
				return true;

			} else { return false; }
			
		break;

		case "SingleMovementTo":

			if (move.time > 0) {			
				if (etime > move.time) {
					etime = move.time;
				}
	
				l_matrix = g_playerTransform[move.index].localMatrix[3];

				var movex = etime * (move.x_loc - l_matrix[0]) / move.time;
				var movey = etime * (move.y_loc - l_matrix[1]) / move.time;
				var movez = etime * (move.z_loc - l_matrix[2]) / move.time;
	
				g_playerTransform[move.index].translate(g_playerJoint[move.index].x, g_playerJoint[move.index].y, g_playerJoint[move.index].z);
				g_playerTransform[move.index].translate(movex, movey, movez);
				g_playerTransform[move.index].translate(-g_playerJoint[move.index].x, -g_playerJoint[move.index].y, -g_playerJoint[move.index].z);

				move.x_rot -= rotx;
				move.y_rot -= roty;
				move.z_rot -= rotz;
				move.time -= etime;
				return true;

			} else { return false; }

		break;

		case "Identity":

			g_playerTransform[move.index].identity();
			return true;
			
		break;

		// if we can pop off empty movements, this will be easier
		case "OrderMovements":	
			for (var i=0; i < move.movements.length; i++) {
				var next_move = move.movements[i];
				var executed = execute_move(next_move, etime);
				if (executed == true) {return true;}	
			}
			return false;
		break;

		case "TogetherMovements":
			var executed = false;
			for (var i=0; i < move.movements.length; i++) {
				var next_move  = move.movements[i];
				if (execute_move(next_move, etime)) { executed = true; }
			}
			return executed;
		break;

	}

}


function reset_me() {
	for (var i=0; i < g_playerTransform.length; i++) {
		g_playerTransform[i].identity();
	}

	g_current_time = 0;

}

// runs the user script
// divides textbox into lines and sends them to be parsed individually (at first)
function run_user_script() {
	
	g_playerMovement = [];		// reset player movements
	g_functions = [];
	g_values = [];
	g_names = [];
	reset_me();

	var error = false;
	var script = document.code_form.code_box.value;

	parse_functions(script);

	var move = go_to("Main", null);

	if (move == null) {
		document.code_form.code_box.value += "\nError";
	} else {
		g_playerMovement.push(move);
	}
}

function stop_user_script() {
  	g_playerMovement = [];		// reset player movements
	g_functions = [];
	g_values = [];
	g_names = [];
}


// preprocess - for now, turn all for () { loops into while () { loops
function pre_process_commands(arr) {
    var sub_array;
    
    for (var i=0; i<arr.length; i++) {
        var test = arr[i];                  // remove later
        
        
        if (arr[i].match(/\b(for)\b\s+\(/)) { //[A-Za-z0-9_\,\.\(\)\+\-\/\*=<>!;]+\)\s*{/)) {
            sub_array = arr[i].split("(", 2);
            sub_array[1] = sub_array[1].replace(/\s/g, "");
            new_commands_array = sub_array[1].split(/[;\)]/);
            arr[i] = "while (" + new_commands_array[1] + ") {";
            arr.splice(i, 0, (new_commands_array[0] + ";"));
            end_function_index = get_index_closing_bracket(arr, i+1);
            arr.splice(end_function_index-1, 0, (new_commands_array[2] + ";"));       
        }
    }
    
    return arr;
    
}

// parse all the functions in the script to an array of functions
function parse_functions(script) {

	var commands = script.split("\n");
        var help_cmds;
        var new_commands;
        var arr;
        var args_names;
        var line;

	
	for (var i=0; i<commands.length; i++) {
		line = commands[i];

		f_index = line.indexOf("function ");

		if ((f_index >= 0) && (line.indexOf("{") > 0)) {				
			line = line.replace(/^\s*/, "").replace(/\s*$/, "");

			// make arguments... put into an array, and send them to execute commands
			arr = line.split(/[()]/);
			name = (arr[0].split(" "))[1];
			args_names = [];
			if (arr[1].length > 0) { args_names = arr[1].split(", "); }
			
                        help_cmds = get_bracketed_commands(commands, i);
                        i += help_cmds.length-1;
			new_commands = pre_process_commands(help_cmds);

                        func = new UserFunction(name, new_commands, args_names);

			g_functions.push(func);
		}
	}

}

// return the commands for the function with name
// return null if not found
function find_function(aName) {

	for (var i=0; i<g_functions.length; i++) {
		if (g_functions[i].name == aName) { 
			return g_functions[i]; 
		}
	}

	return null;

}

// executes the code at function str func
// recursive
// returns the movement created
function go_to(func_name, args_values) {	

	func = find_function(func_name);
	if (func == null) { return null; }

	return (execute_at_commands(func.commands, args_values, func.arg_names));

}

// find and return the index of the closing bracket                 REMOVE THIS
// helper function for find function command
function get_closing_bracket(start) {
	var count = 1;
	
	var i = g_script.indexOf("{", start);
	if (i < 0) { return -1; }

	i += 1;
	
	while (count > 0) {
		if (i>=g_script.length) { return -1; }
		if (g_script[i] == "}") { count -= 1; }
		if (g_script[i] == "{") { count += 1; }
		i++;
	}

	return i;
}

// executes an array of commands using a list of arguments and values
// returns a movement created by these commands
function execute_at_commands(commands, args_values, args_names) {
	var arr = [];

	// first make value and name arrays for valuable - populate with arguments
	var var_values = [];
	for (i in args_values) {
		var_values.push(args_values[i]);
	}

	var var_names = [];
	for (i in args_names) {
		var_names.push(args_names[i]);
	}

	for (var i=1; i<commands.length; i++) {		
		var help_arr = evaluate_line(commands, i, var_values, var_names);
		i = help_arr[1];

		if (help_arr[0] != null) {
			arr.push(help_arr[0]);
		}
	}

	var move = new OrderMovements(arr);
	return move;
}


// takes a single line and does all the processing of operations, variable replacements, comparisons, etc.
function process_line(line, values, names) {
    	
        line = line.replace(/([A-Za-z0-9_\s]+)\+=([A-Za-z0-9\s]+)/, "$1" + "=" + "$1" + "+" + "$2");	
	line = line.replace(/([A-Za-z0-9_\s]+)\-=([A-Za-z0-9\s]+)/, "$1" + "=" + "$1" + "-" + "$2");
	line = line.replace(/([A-Za-z0-9_\s]+)\+\+/, "$1" + "=" + "$1" + "+ 1");	
	line = line.replace(/([A-Za-z0-9_\s]+)\-\-/, "$1" + "=" + "$1" + "- 1");

	line = parse_variable_values(line, values, names);	// puts values into all known variables		
	
	line = line.replace(/([^A-Za-z0-9_])\((-*\d+\.*\d*)\)/g, "$1" + "$2");	// removes redundant ()

	if (line.match(/[\-]/) != null) {
		line = line.replace(/(\d)\-(\d)/g, "$1" + "+-" + "$2");
		line = line.replace(/(\d)\-\-(\d)/g, "$1" + "+" + "$2");
                line = line.replace(/\-\-(\d)/g, "$1");
	}

	line = evaluate_operations(line);			// evaluates all +-/* and removes ()

        if (line.match(/_random/) != null) {
                line = evaluate_random(line);
        }

	line = evaluate_comparisons(line);			// evaluates (==, <, >, <=, >=), stores 0 or 1, removes ()

	if (line.match(/[!&{2}|{2}]/)) {			// adding - evaluate complex &&, ||, !
	
		line = line.replace(/!true/, "false");
		line = line.replace(/!false/, "true");
                
                line = evaluate_logic_expressions(line);
                
	}
        
        return line;
}


// evaluate a single line (at commands[index] and return a move created from it
function evaluate_line(commands, index, values, names) {

	var line = commands[index];
	line = line.replace(/^\s*/, "").replace(/\s*$/, "");		// gets rid of excess white space
        if ((line == "") || (line== "}")) { return [null, index]; }
        var aMove = null;
        
        line = process_line(line, values, names);

// work on this later - imbedded function calls
// find a way to search outside in for these - func(func2(y), func2(z)))
// if you have more () then you can't advance - index
	if (line.match(/\s*\b(_move|_rotate|_moveTo|_reset)\b\([\-0-9., ]*\);/)) {			
		aMove = process_base_function(line);
		return ([aMove, index]);	
	} else {
		var f_call = line.match(/[A-Za-z0-9_\-]+\([\-0-9., ]*\)/);
		while (f_call) {				
			aMove = process_user_defined_function(f_call[0]);
			line = line.replace(/[A-Za-z0-9_\-]+\([\-0-9., ]*\)/, return_register);
			f_call = line.match(/[A-Za-z0-9_\-]+\([\-0-9., ]*\)/);
		}
		// may not want to return
                // because these could contain a return value that requires evaluation
                // or there could be another, imbedded function call - not allowing for now

	}

	if ((line.indexOf("DoInOrder {") >= 0) || (line.indexOf("DoTogether {") >= 0)) {
		var new_commands = get_bracketed_commands(commands, index);
		aMove = process_base_movement(new_commands, values, names);
		index += new_commands.length - 1;
		return ([aMove, index]);
	}

	// conditional (if/then... else)
	if (line.match(/\b(if)\b\s+\b(true|false)\b/)) {
		var new_commands = get_bracketed_commands(commands, index);
		aMove = process_conditional(line, new_commands, values, names);
		index += new_commands.length - 1;
		return ([aMove, index]);
	}
        
        // while loop (while true do )
	if (line.match(/\b(while)\b\s+\b(true)\b/)) {
		var new_commands = get_bracketed_commands(commands, index);
		aMove = process_while_loop(new_commands, values, names);
                index -= 1;
		return ([aMove, index]);
	} else if (line.match(/\b(while)\b\s+\b(false)\b/)) {
            var length = get_index_closing_bracket(commands, index);
            index = length - 1;
            return ([aMove, index]);
        }

	// loop - for (i=0; i < ex; i++) {
	
	create_variables(line, names, values);		// create variables for all "var" and "global" designations
   
	assign_variables(line, names, values);		// assign values to variables [var_name]\s*=\s*\d\.+\d+;
 
	// check return value
	var return_match = line.match(/\b(return)\b\s+\-*\d+\.*\d*/)
	if (return_match) {			
		var return_value = return_match[0].split(/\s+/);
		return_register = return_value[1];
	}
   
	return ([aMove, index]);
}


// evaluate all (*/+-==<>) expressions - recursively - in order */+-
// evaluates () expressions first - and remove () after evaluation
function evaluate_operations(line) {		

	var index_any_ex = line.search(/\-*\d+\.*\d*\s*[\+\*\-\/]\s*\-*\d+\.*\d*/);
	if (index_any_ex < 0) { return line; }

	var expression_string = null;

// we may have to check here for () expressions, but I'm going to skip this first and see if it works

// in order *, /, +, -
	expression_string = line.match(/\-*\d+\.*\d*\s*[\*]\s*\-*\d+\.*\d*/);
	if (expression_string != null) {
		arr = expression_string[0].split(/\s*\*\s*/);
		x = parseFloat(arr[0]);
		y = parseFloat(arr[1]);
		z = x * y;
		line = line.replace(/\-*\d+\.*\d*\s*[\*]\s*\-*\d+\.*\d*/, z);
		
	} else {
		expression_string = line.match(/\-*\d+\.*\d*\s*[\/]\s*\-*\d+\.*\d*/);
		if (expression_string != null) {
			var arr = expression_string[0].split(/\s*\/\s*/);
			x = parseFloat(arr[0]);
			y = parseFloat(arr[1]);
			z = x / y;
			line = line.replace(/\-*\d+\.*\d*\s*[\/]\s*\-*\d+\.*\d*/, z);
		} else {
			expression_string = line.match(/\-*\d+\.*\d*\s*[\+]\s*\-*\d+\.*\d*/);
			if (expression_string != null) {
				var arr = expression_string[0].split(/\s*\+\s*/);
				x = parseFloat(arr[0]);
				y = parseFloat(arr[1]);
				z = x + y;
				line = line.replace(/\-*\d+\.*\d*\s*[\+]\s*\-*\d+\.*\d*/, z);
			} else {
				expression_string = line.match(/\-*\d+\.*\d*\s*[\-]\s*\-*\d+\.*\d*/);
				if (expression_string != null) {
					var arr = expression_string[0].split(/\s*\-\s*/);
					x = parseFloat(arr[0]);
					y = parseFloat(arr[1]);
					z = x - y;
					line = line.replace(/\-*\d+\.*\d*\s*[\-]\s*\-*\d+\.*\d*/, z);
				}
			}
		}
	} 

	line = line.replace(/([^A-Za-z0-9_])\((-*\d+\.*\d*)\)/g, "$1" + "$2");				// remove redundant ()

	return (evaluate_operations(line));
}

// must look like this (x == 5)... spaces and () critical to functioning
function evaluate_comparisons(line) {
        var arr;
              
	var expression_string = line.match(/\(\-*\d+\.*\d*\s*(==|<=|>=|<|>|!=)\s*\-*\d+\.*\d*\)/);
	while (expression_string != null) {
                arr = expression_string[0].split(expression_string[1]);
		x = parseFloat(arr[0].replace(/[\(\)\s*]/, ""));
		op = expression_string[1];
		y = parseFloat(arr[1].replace(/[\(\)\s*]/, ""));

		z = 0;
		switch (op) {
			case "==": z = (x == y); break;
			case "!=": z = (x != y); break;
			case ">=": z = (x >= y); break;
			case "<=": z = (x <= y); break;
			case "<": z = (x < y); break;
			case ">": z = (x > y); break;
		}

		line = line.replace(/\(\-*\d+\.*\d*\s*(==|<=|>=|<|>|!=)\s*\-*\d+\.*\d*\)/, z);
		expression_string = line.match(/\(\-*\d+\.*\d*\s*(==|<=|>=|<|>|!=)\s*\-*\d+\.*\d*\)/);
	}

	return line;
}


// must look like _random(int_low, int_high)
function evaluate_random(line) {
              
	var expression_string = line.match(/_random\(([0-9]+), ([0-9]+)\)/);
	while (expression_string != null) {
		var x = parseFloat(expression_string[1]);
		var y = parseFloat(expression_string[2]);

                var z = Math.floor(Math.random()*(y-x)) + x;

		line = line.replace(/_random\(([0-9]+), ([0-9]+)\)/, z);
		expression_string = line.match(/_random\(([0-9]+), ([0-9]+)\)/);
	}

	return line;
  
}

// evaluates 
// works like operations, do simple function, then remove (), repeat
function evaluate_logic_expressions(line) {
              
        var replace_str = "false";
        
        var logic_expression = line.match(/\b(true|false)\b\s*(&&|\|\|)\s*\b(true|false)\b/);
        if (!logic_expression) { return line; }

        if (logic_expression != null) {
                if (logic_expression[2] == "&&") {
                        if ((logic_expression[1] == "true") && (logic_expression[3] == "true")) {
                             replace_str = "true";
                        }
                } else if (logic_expression[2] == "||") {
                        if ((logic_expression[1] == "true") || (logic_expression[3] == "true")) {
                             replace_str = "true";
                        }
                }

                line = line.replace(/\b(true|false)\b\s*(&&|\|\|)\s*\b(true|false)\b/, replace_str);		
	} 

	line = line.replace(/\(\b(true|false)\b\)/g, "$1");				// remove redundant ()

	return (evaluate_logic_expressions(line));
  
}


// find all the incidents of variable names within the line
// places value from value array into incidents of variable names
function parse_variable_values(line, values, names) {
	
	if ((values.length == 0) && (g_values.length ==0)) { return line; }

	var eq_index = line.search(/[^!=]=[^=><]/);
	
	if (eq_index >= 0) {
		l1 = line.slice(0, (eq_index+1));
		line = line.slice(eq_index+1);
	} else { l1 = ""; }

	// slice this at "=" ... /=[^=><]/
	// only fix variables in 2nd half
	// then put back together


	// first place values into all instances of known variables
	for (var i=0; i<names.length; i++) {
		r_str = "\\b" + names[i] + "\\b";
		reg = new RegExp(r_str, 'g');
		line = line.replace(reg, values[i]);	
	}

	// first place values into all instances of known variables
	for (var i=0; i<g_names.length; i++) {
		r_str = "\\b" + g_names[i] + "\\b";
		reg = new RegExp(r_str, 'g');
		line = line.replace(reg, g_values[i]);	
	}

	return l1 + line;
}


// create variables for all "var" and "global" designations
function create_variables(line, names, values) {	

	local_var = line.match(/var\s[A-Za-z0-0_]/);			// create variables for all "var" designations
	if (local_var != null) {
		var arr = local_var[0].split(" ");
		names.push(arr[1]);
		values.push("");
	}

	global_var = line.match(/global\s[A-Za-z0-0_]/);		// create variables for all "global" designations
	if (global_var != null) {
		var arr2 = global_var[0].split(" ");
		g_names.push(arr2[1]);
		g_values.push("");
	}
}

// assign values to variables [var_name]\s*=\s*\d\.+\d+;
function assign_variables(line, names, values) {	
     
	assignment = line.match(/[A-Za-z0-0_]+\s*=\s*\-*\d+\.*\d*/);
	if (assignment != null) {
		var arr = assignment[0].split("=");
		var name = arr[0].replace(/[\s]/, "");
		var value = arr[1].replace(/[\s;]/, "");
		for (i in names) {
			if (names[i] == name) {
				values[i] = value
				return;
			}
		}
		for (i in g_names) {
			if (g_names[i] == name) {
				g_values[i] = value;
				return;
			}
		}
		g_names.push(name);
		g_values.push(value);
	}
}


// returns an array of lines from this { to the its }
function get_bracketed_commands(cmd, start_index) {
	var new_commands = [];

	var i = start_index;
	count = 1;
	new_commands.push(cmd[i]);
	i++;

	while ( (i < cmd.length) && (count > 0) ) {
		new_commands.push(cmd[i]);
		if (cmd[i].indexOf("}") >= 0) { count -= 1; }
		if (cmd[i].indexOf("{") >= 0) { count += 1; }
		i++;
	}

	return (new_commands);
}

// returns the index of the closing }
function get_index_closing_bracket(cmd, start_index) {
	var i = start_index;
	count = 1;
	i++;

	while ( (i < cmd.length) && (count > 0) ) {			
		if (cmd[i].indexOf("}") >= 0) { count -= 1; }
		if (cmd[i].indexOf("{") >= 0) { count += 1; }
		i++;
	}

	return i;    
    
}

// returns the index of the correct } else {
// returns index at the end of } if not found
function get_index_of_else(cmd) {
	var i = 1;
	count = 1;

	while ( (i < cmd.length) && (count > 0) ) {
		if ((cmd[i].match(/}\s*else\s*{/)) && (count == 1)) { return i; }
		if (cmd[i].indexOf("}") >= 0) { count -= 1; }
		if (cmd[i].indexOf("{") >= 0) { count += 1; }
		i++;
	}
	return i;
}


// don't send the whole line here - just send the function call
function process_user_defined_function(line) {

	function_array = line.split(/[()]/);
	if (function_array.length < 2) {return null;}		// check for correct format

	func_name = function_array[0].replace(/^\s*/, "").replace(/\s*$/, "");
	args = [];
	if (function_array[1].length>0) {
		args = function_array[1].split(", ");
	}

	return (go_to(func_name, args));
}

// process the while loop
// do we need to keep track of "Do_Together" flag?
function process_while_loop(commands, values, names) {
	var arr = [];

	for (var i=1; i<commands.length; i++) {		
		var help_arr = evaluate_line(commands, i, values, names);
		i = help_arr[1];

		if (help_arr[0] != null) {
			arr.push(help_arr[0]); 			// only single movements now
		}
	}

	move = new OrderMovements(arr);

	return move;

}



// process the DoInOrder {} and DoTogether {} composite movement containers 
function process_base_movement(commands, values, names) {
	var arr = [];

	for (var i=1; i<commands.length; i++) {		
		var help_arr = evaluate_line(commands, i, values, names);
		i = help_arr[1];

		if (help_arr[0] != null) {
			arr.push(help_arr[0]); 			// only single movements now
		}
	}

	var move = null;
	if (commands[0].indexOf("DoInOrder {") > -1) {
		move = new OrderMovements(arr);
	} else {
		move = new TogetherMovements(arr);
	}

	return move;

}

// process conditional - if/then
function process_conditional(line, commands, values, names) {
	var arr = [];

	var end_index = commands.length;
	var else_index = get_index_of_else(commands);		// find the index of the correct } else {

	if (line.match(/\b(true)\b/)) {			// if true cycle through 1 to end_index (else_index)
		for (var i=1; i<else_index; i++) {
			var help_arr = evaluate_line(commands, i, values, names);
			i = help_arr[1];

			if (help_arr[0] != null) {
				arr.push(help_arr[0]); 			// only single movements now
			}			
		}
	} else {						// if false and else_index > 0, then cycle else_index+1 - end_index
		for (var i=else_index; i<end_index; i++) {
			var help_arr = evaluate_line(commands, i, values, names);
			i = help_arr[1];

			if (help_arr[0] != null) {
				arr.push(help_arr[0]); 		
			}			
		}
	}

	var move = null;
	move = new OrderMovements(arr);
	return move;

}

// returns the command created, null if error
function process_base_function(line)
{
	line = line.replace(/^\s*/, "").replace(/\s*$/, "");

	function_array = line.split(/[()]/);
	if (function_array.length < 2) {return null;}		// check for correct format

	func_name = function_array[0].replace(/\s*$/, "");
	args = function_array[1].split(", ");

	x = parseFloat(args[1]);
	y = parseFloat(args[2]);
	z = parseFloat(args[3]);
	index = parseFloat(args[0]);
	time = parseFloat(args[4]);

	// check for and execute move = _move(i, x, y, z, time)
	if (func_name == "_move") {
		var move = new SingleMovement(x, y, z, 0, 0, 0, time, index);
		return move;
	}

	// check for and execute move = _moveTo(i, x, y, z, time)
	if (func_name == "_moveTo") {
		var move = new SingleMovementTo(x, y, z, time, index);
		return move;
	}

	// check for and execute move = _reset(index)
	if (func_name == "_reset") {
		var move = new Identity(index);
		return move;
	}

	// check for and execute move = _rotate(i, x, y, z, time)
	if (func_name == "_rotate") {
		var move = new SingleMovement(0, 0, 0, x * 3.14159265 / 180.0, y * 3.14159265 / 180.0, z * 3.14159265 / 180.0, time, index);
		return move;
	}

	return null;

}


/**
 * Called every frame.
 * @param {!o3d.RenderEvent} renderEvent Rendering Information.
 */
function onRender(renderEvent) {
	var elapsedTime = renderEvent.elapsedTime;

	updateClientSize();
	animate(elapsedTime);
};

/**
 * Tracks key down events.
 * @param {Event} e keyboard event.
 */
function onKeyDown(e) {
  g_keyDown[e.keyCode] = true;
}

/**
 * Tracks key up events.
 * @param {Event} e keyboard event.
 */
function onKeyUp(e) {
  g_keyDown[e.keyCode] = false;
}

/**
 * Look at keys.
 */
function handleMoveKeys(elapsedTime) {
}


/**
 * Remove any callbacks so they don't get called after the page has unloaded.
 */
function unload() {
  if (g_client) {
    g_client.cleanup();
  }
}

/* Added by Ken, captures 'tab' inputs as indents instead of navigating to
  the next form */
function setSelectionRange(input, selectionStart, selectionEnd) {
  if (input.setSelectionRange) {
    input.focus();
    input.setSelectionRange(selectionStart, selectionEnd);
  }
  else if (input.createTextRange) {
    var range = input.createTextRange();
    range.collapse(true);
    range.moveEnd('character', selectionEnd);
    range.moveStart('character', selectionStart);
    range.select();
  }
}

function replaceSelection (input, replaceString) {
	if (input.setSelectionRange) {
		var selectionStart = input.selectionStart;
		var selectionEnd = input.selectionEnd;
                
                var scrollTop = input.scrollTop; // fix scrolling issue with Firefox
                input.value = input.value.substring(0, selectionStart) + replaceString +
                                input.value.substring(selectionEnd);
                input.scrollTop = scrollTop;
                
    
		if (selectionStart != selectionEnd){ 
			setSelectionRange(input, selectionStart, selectionStart + 	replaceString.length);
		}else{
			setSelectionRange(input, selectionStart + replaceString.length, selectionStart + replaceString.length);
		}

	}else if (document.selection) {
		var range = document.selection.createRange();

		if (range.parentElement() == input) {
			var isCollapsed = range.text == '';
			range.text = replaceString;

			 if (!isCollapsed)  {
				range.moveStart('character', -replaceString.length);
				range.select();
			}
		}
	}
}

function catchTab(item,e){
	if(navigator.userAgent.match("Gecko")){
		c=e.which;
	}else{
		c=e.keyCode;
	}
	if(c==9){
		replaceSelection(item,"   ");
		setTimeout("document.getElementById('"+item.id+"').focus();",0);	
		return false;
	}
		    
}


</script>

</head>
<body>
  <div id="o3d"></div>
  <div id="code">
    <form name="code_form">
    	<select id="example_list" name="example_list"></select>
    	<button onClick="load_example(); return false;">Load Example</button>
    	<button onClick="share_example(); return false;">Share Example</button>
    <textarea id="textbox" name="code_box" onkeydown="return catchTab(this,event)">
</textarea></form>
  <button onClick="run_user_script(); return false;">Run</button>
  <button onClick="stop_user_script(); return false;">Stop</button>
  <button onClick="reset_me(); return false;">Reset Me</button>
  </div>
  <div id="dialog-message" title="Share">
	<p>
		Share the following url:
	</p>
	<p id="share-url">
		
	</p>
</div>
</body>
</html>


